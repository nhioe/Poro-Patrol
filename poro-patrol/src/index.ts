import { app, BrowserWindow, ipcMain } from "electron"
import fs from "fs"
import https from "https"
import { WINDOW_HEIGHT, WINDOW_WIDTH } from "./theme/constants"

app.commandLine.appendSwitch("ignore-certificate-errors")

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

let mainWindow: BrowserWindow;
const lockfilePath = "C:\\Riot Games\\League of Legends\\lockfile"

const createWindow = (): void => {
  mainWindow = new BrowserWindow({
    height: WINDOW_HEIGHT,
    width: WINDOW_WIDTH,
    resizable: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  })

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)
  // mainWindow.webContents.openDevTools()
}

app.on("ready", createWindow)

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit()
  }
})

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

let lockfileData: { port: string; password: string; protocol: string } | null = null

const readLockfile = () => {
  try {
    if (!fs.existsSync(lockfilePath)) {
      console.error("Lockfile not found! Ensure LoL Client is running.")
      lockfileData = null
      return null
    }

    const lockfileContent = fs.readFileSync(lockfilePath, "utf8")
    const [name, pid, port, password, protocol] = lockfileContent.split(":")

    lockfileData = { port, password, protocol }
    return lockfileData
  } catch (error) {
    console.error("Error reading lockfile:", error)
    return null
  }
}

ipcMain.handle("get-lockfile-data", () => {
  return readLockfile() || lockfileData
})

ipcMain.handle("league-api-request", async (event, endpoint, method = "GET", body = null) => {
  const lockfile = readLockfile() || lockfileData
  if (!lockfile) {
    return { error: "Lockfile data is missing. Ensure the client is running." }
  }

  const { protocol, port, password } = lockfile
  const baseURL = `${protocol}://127.0.0.1:${port}`
  
  const url = `${baseURL}${endpoint}`;

  return new Promise((resolve, reject) => {
    const options = {
      method,
      headers: {
        Authorization: `Basic ${Buffer.from(`riot:${password}`).toString("base64")}`,
        "Content-Type": "application/json",
      },
      rejectUnauthorized: false,
    }

    const req = https.request(url, options, (res) => {
      let data = ""
      res.on("data", (chunk) => {
        data += chunk
      })
      res.on("end", () => {
        try {
          const jsonData = data ? JSON.parse(data) : {}
          resolve(jsonData)
        } catch (error) {
          resolve({ error: "Failed to parse response", data })
        }
      })
    })

    req.on("error", (error) => {
      console.error(`Error making request to ${endpoint}:`, error)
      resolve({ error: error.message })
    })

    if (body) req.write(JSON.stringify(body))
    req.end()
  })
})

ipcMain.handle("bring-to-front", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized()) {
      mainWindow.restore();
    }
    mainWindow.show();
    mainWindow.focus();
  }
}) 

